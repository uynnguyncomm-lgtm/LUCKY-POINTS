<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>M√°y G·∫Øp Th√∫ - Tr·ª•c ƒê·∫©y (Final Fix)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        body { 
            margin: 0; padding: 0; 
            background: #222; 
            height: 100vh; 
            display: flex; justify-content: center; align-items: center; 
            overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; 
        }

        #game-container {
            position: relative;
            width: 500px;
            height: 750px;
            max-width: 100%; max-height: 100%;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 20px;
            overflow: hidden;
            /* L·ªõp 1: H√¨nh n·ªÅn n·∫±m sau c√πng */
            background-color: #ffcdd2; 
            background-image: url('bg.png'); 
            background-size: 100% 100%; 
            background-position: center;
            background-repeat: no-repeat;
        }

        canvas { 
            display: block; width: 100%; height: 100%;
            /* L·ªõp 2: Canvas trong su·ªët ƒë√® l√™n h√¨nh n·ªÅn */
            background: transparent !important; 
        }

        #controls-layer {
            position: absolute; 
            bottom: 30px; 
            left: 0; width: 100%; height: 120px;
            display: flex; justify-content: center; align-items: center;
            z-index: 20;
        }

        #joystick-zone {
            position: absolute;
            left: 60px; bottom: 20px;
            width: 90px; height: 90px;
            background: rgba(255, 255, 255, 0.1); 
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-knob {
            width: 50px; height: 50px;
            background: radial-gradient(circle at 30% 30%, #e74c3c, #c0392b);
            border-radius: 50%; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 5px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.4);
        }

        #drop-btn {
            position: absolute;
            right: 60px; bottom: 25px;
            width: 80px; height: 80px;
            background: radial-gradient(circle at 30% 30%, #2ecc71, #27ae60);
            border-radius: 50%;
            border: 4px solid #fff;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            cursor: pointer; pointer-events: auto;
            display: flex; justify-content: center; align-items: center;
            color: white; font-weight: bold; font-size: 18px; user-select: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }
        #drop-btn:active { transform: scale(0.95); background: #219150; }

        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; justify-content: center; align-items: center; flex-direction: column; }
        .box { background: white; padding: 40px; border-radius: 30px; text-align: center; border: 8px solid #ff7979; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: relative; max-width: 80%; }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .prize-display { width: 100px; height: 100px; object-fit: contain; margin-bottom: 10px; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.2)); }
        h2 { color: #d63031; margin: 10px 0; font-size: 28px; }
        p { font-size: 20px; color: #333; margin-bottom: 25px; line-height: 1.5; }
        button.modal-btn { padding: 12px 30px; background: linear-gradient(to right, #6ab04c, #badc58); color: white; border: none; border-radius: 50px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 5px 15px rgba(106, 176, 76, 0.4); transition: transform 0.2s; }
        button.modal-btn:hover { transform: scale(1.05); }
        #game-over { display: none; color: white; font-size: 30px; font-weight: bold; text-align: center; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="controls-layer">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="drop-btn">G·∫ÆP</div>
    </div>
</div>

<div id="modal">
    <div class="box">
        <img id="modal-img" class="prize-display" src="" alt="Prize">
        <h2>Ch√∫c M·ª´ng!</h2>
        <p id="wish-text">...</p>
        <button class="modal-btn" onclick="continueGame()">Ti·∫øp T·ª•c Ch∆°i</button>
    </div>
    <div id="game-over">
        üéâ B·∫†N ƒê√É G·∫ÆP H·∫æT QU√Ä! üéâ<br>
        <button class="modal-btn" onclick="location.reload()" style="margin-top:20px">Ch∆°i L·∫°i T·ª´ ƒê·∫ßu</button>
    </div>
</div>

<script>
// --- C·∫§U H√åNH T·ªåA ƒê·ªò V√Ä K√çCH TH∆Ø·ªöC ---
const BOUNDS = {
    width: 500,
    height: 750,
    railY: 135,      
    floorY: 550,     
    holeX: 95,       
    holeWidth: 110,  
    // TƒÉng ƒë·ªô d√†y t∆∞·ªùng l√™n C·ª∞C ƒê·∫†I ƒë·ªÉ kh√¥ng bao gi·ªù b·ªã xuy√™n qua
    wallThickness: 500 
};

// Nh√≥m va ch·∫°m ƒë·∫∑c bi·ªát
const GROUP_CLAW = -1; 

window.addEventListener('load', function() {
    try {
        const CONFIG = { 
            clawImage: 'claw.png',
            rodImage: 'rod.png', 
            prizeImages: [
                'prize1.png', 'prize2.png', 'prize3.png', 'prize4.png', 'prize5.png',
                'prize6.png', 'prize7.png', 'prize8.png', 'prize9.png', 'prize10.png'
            ],
            count: 10 
        };

        const WISHES = [
            "Ti·ªÅn ƒë·∫ßy t√∫i! üí∞", "T√¨nh ƒë·∫ßy tim! ‚ù§Ô∏è", "H·ªçc gi·ªèi chƒÉm ngoan! üìö", 
            "V·∫°n s·ª± nh∆∞ √Ω! ‚ú®", "S·ª©c kh·ªèe v√¥ bi√™n! üí™", "May m·∫Øn ng·∫≠p tr√†n! üçÄ",
            "Crush s·∫Ω th√≠ch b·∫°n! üíò", "ƒÇn m√£i kh√¥ng b√©o! üçï", "Lu√¥n y√™u ƒë·ªùi! üòä", "Gia ƒë√¨nh h·∫°nh ph√∫c! üë®‚Äçüë©‚Äçüëß‚Äçüë¶"
        ];

        const { Engine, Render, Runner, World, Bodies, Body, Events, Constraint, Composite, Vector } = Matter;
        
        // TƒÉng ƒë·ªô ch√≠nh x√°c c·ªßa Engine ƒë·ªÉ tr√°nh l·ªói xuy√™n t∆∞·ªùng
        const engine = Engine.create({
            positionIterations: 10,
            velocityIterations: 10
        });
        const world = engine.world;
        
        const render = Render.create({
            element: document.getElementById('game-container'), 
            engine: engine,
            options: { 
                width: BOUNDS.width, height: BOUNDS.height, 
                wireframes: false, 
                background: 'transparent'
            }
        });

        // --- X√ÇY D·ª∞NG KHUNG M√ÅY (T∆∞·ªùng si√™u d√†y) ---
        // S√†n ph·∫£i ch·ª©a th√∫ (D√†y 200px)
        const floorRightWidth = BOUNDS.width - BOUNDS.holeWidth - 60; 
        const floorRightX = 160 + floorRightWidth/2; 
        const floorRight = Bodies.rectangle(floorRightX, BOUNDS.floorY + 100, floorRightWidth, 200, { isStatic: true, render: { visible: false } });

        // V√°ch ngƒÉn h·ªë (Barrier)
        const barrierHeight = 150; 
        const holeBarrier = Bodies.rectangle(160, BOUNDS.floorY - barrierHeight/2 + 20, 20, barrierHeight, {
            isStatic: true,
            render: { fillStyle: 'rgba(255, 255, 255, 0.1)', strokeStyle: 'rgba(255, 255, 255, 0.2)', lineWidth: 1 } 
        });

        // T∆∞·ªùng tr√°i & ph·∫£i (D√†y 500px, ƒë·∫∑t l√πi ra ngo√†i m√†n h√¨nh)
        const leftWall = Bodies.rectangle(0 - BOUNDS.wallThickness/2 + 30, BOUNDS.height/2, BOUNDS.wallThickness, BOUNDS.height * 2, { isStatic: true, render: { visible: false } });
        const rightWall = Bodies.rectangle(BOUNDS.width + BOUNDS.wallThickness/2 - 30, BOUNDS.height/2, BOUNDS.wallThickness, BOUNDS.height * 2, { isStatic: true, render: { visible: false } });
        
        // Tr·∫ßn nh√†
        const ceiling = Bodies.rectangle(BOUNDS.width/2, -200, BOUNDS.width * 2, 400, { isStatic: true, render: { visible: false } });

        const holeSensor = Bodies.rectangle(BOUNDS.holeX, BOUNDS.floorY + 100, BOUNDS.holeWidth, 20, { 
            isStatic: true, isSensor: true, label: 'hole', render: { visible: false } 
        });

        World.add(world, [floorRight, holeBarrier, leftWall, rightWall, ceiling, holeSensor]);

        // --- T·∫†O TH√ö B√îNG ---
        let activePrizes = [];
        for (let i = 0; i < CONFIG.count; i++) {
            const imgName = CONFIG.prizeImages[i % CONFIG.prizeImages.length];
            const startX = Math.random() * (floorRightWidth - 80) + 190; 
            const startY = Math.random() * 150 + 350; 

            const p = Bodies.circle(startX, startY, 26, { 
                restitution: 0.1,    
                friction: 0.8,     
                frictionAir: 0.08, // TƒÉng c·∫£n gi√≥ ƒë·ªÉ th√∫ r∆°i ch·∫≠m h∆°n, √≠t vƒÉng
                density: 0.002, 
                label: 'prize',
                collisionFilter: { group: 0 },
                render: { sprite: { texture: imgName, xScale: 0.22, yScale: 0.22 } } 
            });
            p.wish = WISHES[i % WISHES.length];
            p.imgSrc = imgName;
            activePrizes.push(p);
            World.add(world, p);
        }

        // --- T·∫†O CLAW ---
        const claw = Bodies.rectangle(250, BOUNDS.railY + 40, 50, 50, {
            frictionAir: 0.05, 
            label: 'claw', 
            density: 0.05, 
            collisionFilter: { group: GROUP_CLAW },
            render: { sprite: { texture: CONFIG.clawImage, xScale: 0.25, yScale: 0.25 } }
        });
        Body.setInertia(claw, Infinity);
        World.add(world, claw);

        // --- D√ÇY C√ÅP ---
        const cable = Constraint.create({
            pointA: { x: 250, y: BOUNDS.railY },
            bodyB: claw,
            pointB: { x: 0, y: -25 },
            length: 60, 
            stiffness: 1, 
            render: { visible: false } 
        });
        World.add(world, cable);

        // --- T·∫¢I ·∫¢NH TR·ª§C ---
        const rodImg = new Image();
        rodImg.src = CONFIG.rodImage;

        // --- V·∫º TR·ª§C G·∫ÆP & D√ÇY N·ªêI ---
        // S·ª¨ D·ª§NG beforeRender ƒê·ªÇ TR·ª§C N·∫∞M D∆Ø·ªöI TAY G·∫ÆP (CLAW) V√Ä TR√äN BACKGROUND
        Events.on(render, 'beforeRender', function() {
            const ctx = render.context;
            const startX = cable.pointA.x;
            const startY = cable.pointA.y; 
            const endY = claw.position.y - 25; 

            // V·∫Ω tr·ª•c n·ªëi (H√¨nh ·∫£nh ho·∫∑c v·∫Ω tay)
            if (rodImg.complete && rodImg.naturalWidth !== 0) {
                 // TƒÉng chi·ªÅu r·ªông l√™n 150 ƒë·ªÉ to h∆°n Claw
                 const width = 150; 
                 const height = endY - startY; 
                 // V·∫Ω h√¨nh tr·ª• n·ªëi t·ª´ thanh ray xu·ªëng tay g·∫Øp
                 ctx.drawImage(rodImg, startX - width/2, startY, width, height);
            } else {
                // Fallback: V·∫Ω m·ªôt thanh kim lo·∫°i r√µ r√†ng
                ctx.fillStyle = '#b2bec3'; 
                const rodW = 150;
                ctx.fillRect(startX - rodW/2, startY, rodW, endY - startY);
                
                // Vi·ªÅn tr·ª•c
                ctx.beginPath();
                ctx.moveTo(startX - rodW/2, startY);
                ctx.lineTo(startX - rodW/2, endY);
                ctx.moveTo(startX + rodW/2, startY);
                ctx.lineTo(startX + rodW/2, endY);
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // ƒê√£ x√≥a kh·ªõp n·ªëi tr√™n thanh ray theo y√™u c·∫ßu
        });

        // --- LOGIC GAME ---
        let state = 'IDLE'; 
        let joint = null;
        let caughtItem = null;
        let joyX = 0;
        let grabTimer = 0;

        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        const dropBtn = document.getElementById('drop-btn');

        function handleJoystick(e) {
            e.preventDefault();
            const rect = joystickZone.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let dx = clientX - centerX;
            const max = rect.width/2;
            
            // Ch·ªâ t√≠nh tr·ª•c ngang
            if (dx > max) dx = max; 
            if (dx < -max) dx = -max;
            
            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), -50%)`;
            joyX = dx / max;
        }

        function endJoystick() {
            joystickKnob.style.transform = `translate(-50%, -50%)`;
            joyX = 0;
        }

        joystickZone.addEventListener('mousedown', (e) => {
            document.addEventListener('mousemove', handleJoystick);
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', handleJoystick);
                endJoystick();
            });
            handleJoystick(e);
        });
        joystickZone.addEventListener('touchstart', (e) => {
            document.addEventListener('touchmove', handleJoystick, {passive:false});
            document.addEventListener('touchend', () => {
                document.removeEventListener('touchmove', handleJoystick);
                endJoystick();
            });
            handleJoystick(e);
        }, {passive:false});

        function triggerDrop() {
            if (state === 'IDLE') state = 'DROP';
        }
        dropBtn.addEventListener('mousedown', triggerDrop);
        dropBtn.addEventListener('touchstart', (e) => { e.preventDefault(); triggerDrop(); });

        // --- GAME LOOP ---
        Events.on(engine, 'beforeUpdate', () => {
            if (state === 'IDLE') {
                let targetX = cable.pointA.x + joyX * 6;
                if (targetX < 50) targetX = 50; 
                if (targetX > 450) targetX = 450;
                
                cable.pointA.x = targetX;
                cable.length = 60; 

                Body.setPosition(claw, { x: targetX, y: BOUNDS.railY + 40 });
                Body.setVelocity(claw, { x: 0, y: 0 }); 
            }
            
            else if (state === 'DROP') {
                cable.length += 8; 
                Body.setVelocity(claw, {x: 0, y: 8}); 
                Body.setPosition(claw, { x: cable.pointA.x, y: claw.position.y }); 

                if(claw.position.y > BOUNDS.floorY - 30 || cable.length > 450) {
                    state = 'GRABBING'; 
                    grabTimer = 0;
                }
            }

            else if (state === 'GRABBING') {
                Body.setVelocity(claw, {x: 0, y: 0});
                grabTimer += 1000/60; 
                
                if (grabTimer > 500) { 
                    // LOGIC G·∫ÆP
                    let closest = null;
                    let minDist = 70; 

                    for (let prize of activePrizes) {
                        const d = Vector.magnitude(Vector.sub(prize.position, claw.position));
                        if (d < minDist) {
                            minDist = d;
                            closest = prize;
                        }
                    }
                    
                    if (closest) {
                        caughtItem = closest;
                        // T·∫Øt va ch·∫°m
                        caughtItem.collisionFilter.group = GROUP_CLAW;

                        joint = Constraint.create({
                            bodyA: claw, bodyB: closest, 
                            length: 1, 
                            stiffness: 0.2, 
                            damping: 0.1,   
                            render: { visible: false }
                        });
                        World.add(world, joint);
                    }
                    state = 'RETRACT';
                }
            }
            
            else if (state === 'RETRACT') {
                cable.length -= 6;
                Body.setVelocity(claw, {x: 0, y: -6});
                Body.setPosition(claw, { x: cable.pointA.x, y: claw.position.y }); 

                if (cable.length <= 65) {
                    cable.length = 60;
                    if (joint) {
                        state = 'RETURN_HOME'; 
                    } else {
                        state = 'IDLE'; 
                        joint = null;   
                    }
                }
            }
            
            else if (state === 'RETURN_HOME') {
                const targetX = BOUNDS.holeX;
                const dx = targetX - cable.pointA.x;
                
                if (Math.abs(dx) > 4) {
                    const dir = Math.sign(dx);
                    cable.pointA.x += dir * 4;
                    Body.setPosition(claw, {x: cable.pointA.x, y: claw.position.y});
                } else {
                    state = 'RELEASE_TO_HOLE';
                }
            }
            
            else if (state === 'RELEASE_TO_HOLE') {
                if (joint) {
                    World.remove(world, joint); 
                    
                    if(caughtItem) {
                        caughtItem.collisionFilter.group = 0; 
                        Body.applyForce(caughtItem, caughtItem.position, {x: 0, y: 0.05});
                    }
                    
                    joint = null;
                }
            }
        });

        // --- X·ª¨ L√ù R∆†I V√ÄO L·ªñ ---
        Events.on(engine, 'collisionStart', (e) => {
            e.pairs.forEach(pair => {
                const a = pair.bodyA, b = pair.bodyB;
                if (a.label === 'hole' || b.label === 'hole') {
                    const body = a.label === 'hole' ? b : a;
                    if (body.label === 'prize' && body === caughtItem) {
                        winPrize(body);
                    }
                }
            });
        });

        function winPrize(prizeBody) {
            World.remove(world, prizeBody);
            const index = activePrizes.indexOf(prizeBody);
            if (index > -1) activePrizes.splice(index, 1);

            const modal = document.getElementById('modal');
            const img = document.getElementById('modal-img');
            const txt = document.getElementById('wish-text');
            img.src = prizeBody.imgSrc;
            txt.innerText = prizeBody.wish;
            modal.style.display = 'flex';
            
            document.querySelector('.box').style.display = 'block';
            document.getElementById('game-over').style.display = 'none';

            if (activePrizes.length === 0) {
                setTimeout(() => {
                    document.querySelector('.box').style.display = 'none';
                    document.getElementById('game-over').style.display = 'block';
                }, 3000);
            }
        }

        window.continueGame = function() {
            document.getElementById('modal').style.display = 'none';
            caughtItem = null;
            state = 'IDLE';
            cable.pointA.x = 250; 
        };

        document.addEventListener('keydown', (e) => {
            if (state === 'IDLE') {
                if (e.key === 'ArrowRight') joyX = 1;
                if (e.key === 'ArrowLeft') joyX = -1;
                if (e.key === ' ' || e.code === 'Space') triggerDrop();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (['ArrowRight','ArrowLeft'].includes(e.key)) joyX = 0;
        });

        Render.run(render);
        Runner.run(Runner.create(), engine);
    } catch (err) { alert("L·ªói: " + err.message); }
});
</script>
</body>
</html>